---
title: 并发编程
date: 2024-6-17
updated: 2024-6-17
categories: "面试"
tags: 
	- "并发编程"
	- "八股文"
---

# 并发编程

![image-20240617170924074](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240617170924074.png)

# 线程基础

## 线程与进程的区别

程序由**指令**和**数据**组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。**进程就是用来加载指令、管理内存、管理IO的。**

**当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。**

一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行

一个进程之内可以分为一到多个线程。

- 进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务
- 不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的时从一个线程切换到另一个线程)

## 并行和并发有什么区别

单核CPU

- 单核CPU下线程实际上还是串行执行
- 操作系统中，有一个组件叫做任务调度器，将`cpu`的时间片(windows下时间片最小约为15ms)分给不同的程序使用，只是由于`cpu`在线程间(时间片很短)的切换非常快，人类感觉是同时进行的

- 微观串行，宏观并行
- 一般会将这种线程轮流使用CPU的做法称为并发

多核CPU

- 每个核都可以调度运行线程，这时候可以是并行的

> **并发是指同一时间应对多件事情的能力**
>
> **并行是同一时间动手做多件事情的能力**

## 创建线程的方式有哪些

四种方式

- 继承Thread类
- 实现Runnable接口
- 实现Callable接口
- 线程池创建线程

###  继承`Thread`类

```java
package 八股文;
public class ThreadDemo extends Thread {
    
    @Override
    public void run() {
        System.out.println("MyThread run...");
    }


    public static void main(String[] args) {
        // 创建 Thread 对象
        ThreadDemo t1 = new ThreadDemo();
        ThreadDemo t2 = new ThreadDemo();
        
        // 调用 start 方法启动线程
        t1.start();
        t2.start();
    }
}
```

### 实现Runnable接口

```java
public class RunnableDemo implements Runnable{

    @Override
    public void run() {
        System.out.println("MyRunnable run...");
    }

    public static void main(String[] args) {
        // 创建 MyRunnable 对象
        RunnableDemo mr = new RunnableDemo();
        
        // 创建线程对象
        Thread t1 = new Thread(mr);
        Thread t2 = new Thread(mr);

        t1.start();
        t2.start();
    }
    
}
```

### 实现Callable接口

```java
public class CallableDemo implements Callable<String>{

    @Override
    public String call() throws Exception {
        System.out.println(Thread.currentThread().getName());
        return "ok";
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        // 创建 Callable 对象
        CallableDemo cd = new CallableDemo();
        // 创建 FutureTask 对象
        FutureTask<String> ft = new FutureTask<>(cd);
        // 创建 Thread 对象
        Thread t1 = new Thread(ft);
        Thread t2 = new Thread(ft);

        // 调用 Start 方法
        t1.start();
        // 调用 ft 的 get 方法获取执行结果
        String result = ft.get();
        // 输出
        System.out.println(result);
    }
    
}
```

### 线程池创建线程

```java
/**
 * ExecutorDemo
 */
public class ExecutorDemo implements Runnable{

    @Override
    public void run() {
        System.out.println("MyRunnable run...");
    }

    public static void main(String[] args) {
        // 创建线程池对象
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        // 提交任务
        threadPool.submit(new ExecutorDemo());

        // 关闭线程池
        threadPool.shutdown();
    }
    
}
```

### `Runnable`和`Callable`有什么区别呢？

1. Runnable 接口 run 方法没有返回值
2. Callable 接口 call 方法有返回值，是个泛型，和Future、`FutureTask` 配合可以用来获取异步执行的结果
3. Callable 接口的 call 方法允许抛出异常；而 Runnable 接口的 run 方法的异常只能在内部消化，不能继续上抛

### run()和start()有什么区别？

- `start()`: 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次
- `run()`: 封装了要被线程执行的代码，可以被调用多次

## 线程中包括哪些状态、状态之间是如何变化的

```java
public enum State {
    // 尚未启动的线程的线程状态
    NEW,
    // 可运行线程的线程状态
    RUNNABLE,
    // 线程阻塞等待监视器锁的线程状态
    BLOACKED,
    // 等待线程的线程状态
    WAITING,
    // 具有指定等待时间的等待线程的线程状态
    TIMED_WAITTING,
    // 已终止线程的线程状态，线程已完成执行
    TERMINATED;
}
```

![image-20240617195801269](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240617195801269.png)

## 新建T1、T2、T3三个线程如何保证它们按顺序执行？

使用线程中的join()方法

- join() 等待线程运行结束

> ​	阻塞调用此方法的线程进入timed_waiting直到线程t执行完成后，此线程再继续执行

## `notify()`和 `notifyAll()`有什么区别?

- `notifyAll`:唤醒所有wait的线程
- `notify`：只随机唤醒一个wait线程

## wait和sleep方法的不同

共同点：

wait(), wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态

不同点：

1. 方法归属不同

- sleep(long) 是 Thread 的静态方法
- wait(), wait(long) 都是 Object 的成员方法，每个对象都有

2. 醒来时机不同

- 执行sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来
- wait(long) 和 wait() 还可以被 notify 唤醒，wait()如果不唤醒就会一直等待下去
- 他们都可以被打断唤醒

3. 锁特性不同

- wait方法的调用必须先获取wait对象的锁，而sleep则无此限制
- wait方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃cpu，但你们还可以用）
- 而sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃cpu，你们也用不了）

## 如何停止一个正在运行的线程

1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止
2. 使用 stop 方法强制终止（不推荐，方法已作废）
3. 使用 interrupt 方法中断线程
   - 打断阻塞的线程（sleep，wait，join）的线程，线程会抛出`InterruptedException`异常
   - 打断正常的线程，可以根据打断状态来标记是否退出线程

# 线程安全

## `synchronized`关键字的底层原理

> ​	Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住

### Monitor

> ​	Monitor 被翻译为监视器，是由jvm提供，c++语言实现

Monitor

- `WaitSet`: 存储当前获取锁的线程，只能有一个线程可以获取
- `EntryList`: 关联没有抢到锁的线程，处于Blocked状态的线程
- `Owner`: 关联调用了wait方法的线程，处于Waiting状态的线程

> - Monitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。
> - 在JDK1.6引入了两种新型锁机制：**偏向锁**和**轻量级锁**，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。

### 对象的内存结构

在`HotSpot`虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充

![image-20240617212816006](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240617212816006.png)

`MarkWord`

![image-20240617212953619](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240617212953619.png)

### Monitor 重量级锁

> ​	每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向Monitor对象的指针

### 轻量级锁

> ​	在很多的情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。

