```
title: Redis
date: 2024-6-4
updated: 2024-6-4
categories: "面试"
tags: 
	- "Redis"
	- "八股文"
```

# Redis开篇

## 使用场景

- 缓存
  - 穿透、击穿、雪崩
  - 双写一致、持久化
  - 数据过期、淘汰策略
- 分布式锁
  - setnx、redission
- 计数器
- 保存token
- 消息队列
- 延迟队列

## 其他面试题

- 集群
  - 主从
  - 哨兵
  - 集群
- 事务
- Redis为什么快

# 缓存穿透

> ​	查询一个**不存在**的数据，`mysql`查询不到数据也不会直接写入缓存，就会导致每次请求都请求数据库

**解决方案**

1. 缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存。

- 优点：简单
- 缺点：消耗内存，可能会发生不一致的问题
  - 比如当存在`redis`中的数据为null时，但是此时数据库中又添加了这个数据，就会发生不一致的问题。

2. 布隆过滤器

![image-20240604195839597](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240604195839597.png)

那什么是布隆过滤器呢？

**bitmap(位图)**:相当于是一个以`(bit)位`为单位的数组，数组中每个单元只能存储二进制数`0`或者`1`

**作用**：可以用于检索一个元素是否在一个集合中

- 存储数据：id唯一的数据，经过多个hash函数获取hash值，根据hash值计算数组对应位置改为`1`
- 查询数据：使用相同hash函数获取hash值，判断对应位置是否都为`1`

- 优点：内存占用较少，没有多余key
- 缺点：实现复杂，存在误判

# 缓存击穿

> ​	给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把数据库压垮。

**解决方案**

1. 互斥锁

![image-20240604202453456](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240604202453456.png)

- **强一致性**
- **性能差**

2. 逻辑过期

![image-20240604202733652](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240604202733652.png)

- **高可用**
- **性能优**
- **不能保证数据一致**

# 缓存雪崩

> ​	同一时间段大量的key同时失效或者Redis宕机，导致大量请求到达数据库，带来巨大压力。

**解决方案**

- 给不同的Key的TTL（过期时间）添加随机值
- 利用Redis集群提高服务的可用性
  - 哨兵模式
  - 集群模式
- 给缓存业务添加降级限流策略
  - nginx
  - spring cloud gateway
- 给业务添加多级缓存
  - Guava
  - Caffeine

# 双写一致性

> ​	当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致。

一定要结合项目背景，不同的项目背景有着不同的解决方案

1. 一致性要求高：一般是读多写少的场景，所以可以采用分布式锁的方式

- 共享锁：读锁`readLock`，加锁之后，其他线程可以共享读操作
- 排他锁：`writeLock`也叫独占锁，加锁之后，阻塞其他线程写操作

- **强一致性**
- **性能低**

2. 允许延迟一致：

- 读操作：缓存命中，直接返回；缓存未命中，写入缓存，设定超时时间
- 写操作：**延迟双删**，有脏数据风险

```mermaid
graph LR;
L(删除缓存)
-->
C(修改数据库)
--延迟-->
R(删除缓存)
```

3. 异步通知保证数据的最终一致性

- 通过MQ（消息队列）
- 基于Canal的异步通知

![image-20240604210423460](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240604210423460.png)

![image-20240604210625694](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240604210625694.png)

# Redis持久化

> Redis中提供了两种数据持久化的方式：
>
> 1. RDB
> 2. AOF

## 什么是RDB呢

> ​	RDB(Redis Database Backup file)Redis 数据备份文件，也被叫Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。

```shell
[flyone ~]# redis-cli
127.0.0.1:6379> save # 由Redis主进程来执行RDB，会阻塞所有命令
ok
127.0.0.1:6379> bgsave # 开启子进程执行RDB，避免主进程收到影响
Background saving started
```

上面的命令是进行主动的备份

Redis内部有触发RDB的机制，可以在`redis.conf`文件中找到，格式如下：

```shell
# 900s内，如果至少有一个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
```

## RDB的执行原理是什么呢

> ​	在Linux系统中，是不能直接拷贝物理内存中的数据的，但是有着**虚拟内存**的概念，而进程中有着**页表**的概念，它记录着虚拟地址与物理地址的映射关系。就可以通过**页表**去共享内存数据
>
> ​	`bgsave`开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。
>
> ​	`fork`采用的是`copy-on-write`技术
>
> - 当主进程执行读操作时，访问共享内存；
> - 当主进程执行写操作时，则会拷贝一份数据，执行写操作。

## 什么是AOF呢

> ​	AOF全称Append Only File（追加文件）。Redis处理的每一个`写命令`都会记录在AOF文件中，可以看作是日志文件。

AOF默认是关闭的，需要修改Redis.conf配置文件来开启AOP:

```shell
#是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename "appendonly.aof"
```

AOF的命令记录的频率也可以通过redis.conf文件来配置：

```shell
# 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完先放入AOF缓存区，然后表示每隔1s将缓冲区数据写道AOF文件
appendfsync everysec
# 写命令执行完毕先放入AOF缓存区，由操作系统决定何时将缓存区内容写回磁盘
appendfsync no
```



