---
title: Redis
date: 2024-6-4
updated: 2024-6-6
categories: "面试"
tags: 
	- "Redis"
	- "八股文"
---

# Redis开篇

## 使用场景

- 缓存
  - 穿透、击穿、雪崩
  - 双写一致、持久化
  - 数据过期、淘汰策略
- 分布式锁
  - setnx、redission
- 计数器
- 保存token
- 消息队列
- 延迟队列

## 其他面试题

- 集群
  - 主从
  - 哨兵
  - 集群
- 事务
- Redis为什么快

# 缓存穿透

> ​	查询一个**不存在**的数据，`mysql`查询不到数据也不会直接写入缓存，就会导致每次请求都请求数据库

**解决方案**

1. 缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存。

- 优点：简单
- 缺点：消耗内存，可能会发生不一致的问题
  - 比如当存在`redis`中的数据为null时，但是此时数据库中又添加了这个数据，就会发生不一致的问题。

2. 布隆过滤器

![image-20240604195839597](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240604195839597.png)

那什么是布隆过滤器呢？

**bitmap(位图)**:相当于是一个以`(bit)位`为单位的数组，数组中每个单元只能存储二进制数`0`或者`1`

**作用**：可以用于检索一个元素是否在一个集合中

- 存储数据：id唯一的数据，经过多个hash函数获取hash值，根据hash值计算数组对应位置改为`1`
- 查询数据：使用相同hash函数获取hash值，判断对应位置是否都为`1`

- 优点：内存占用较少，没有多余key
- 缺点：实现复杂，存在误判

# 缓存击穿

> ​	给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把数据库压垮。

**解决方案**

1. 互斥锁

![image-20240604202453456](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240604202453456.png)

- **强一致性**
- **性能差**

2. 逻辑过期

![image-20240604202733652](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240604202733652.png)

- **高可用**
- **性能优**
- **不能保证数据一致**

# 缓存雪崩

> ​	同一时间段大量的key同时失效或者Redis宕机，导致大量请求到达数据库，带来巨大压力。

**解决方案**

- 给不同的Key的TTL（过期时间）添加随机值
- 利用Redis集群提高服务的可用性
  - 哨兵模式
  - 集群模式
- 给缓存业务添加降级限流策略
  - nginx
  - spring cloud gateway
- 给业务添加多级缓存
  - Guava
  - Caffeine

# 双写一致性

> ​	当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致。

一定要结合项目背景，不同的项目背景有着不同的解决方案

1. 一致性要求高：一般是读多写少的场景，所以可以采用分布式锁的方式

- 共享锁：读锁`readLock`，加锁之后，其他线程可以共享读操作
- 排他锁：`writeLock`也叫独占锁，加锁之后，阻塞其他线程写操作

- **强一致性**
- **性能低**

2. 允许延迟一致：

- 读操作：缓存命中，直接返回；缓存未命中，写入缓存，设定超时时间
- 写操作：**延迟双删**，有脏数据风险

```mermaid
graph LR;
L(删除缓存)
-->
C(修改数据库)
--延迟-->
R(删除缓存)
```

3. 异步通知保证数据的最终一致性

- 通过MQ（消息队列）
- 基于Canal的异步通知

![image-20240604210423460](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240604210423460.png)

![image-20240604210625694](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240604210625694.png)

# Redis持久化

> Redis中提供了两种数据持久化的方式：
>
> 1. RDB
> 2. AOF

## 什么是RDB呢

> ​	RDB(Redis Database Backup file)Redis 数据备份文件，也被叫Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。

```shell
[flyone ~]# redis-cli
127.0.0.1:6379> save # 由Redis主进程来执行RDB，会阻塞所有命令
ok
127.0.0.1:6379> bgsave # 开启子进程执行RDB，避免主进程收到影响
Background saving started
```

上面的命令是进行主动的备份

Redis内部有触发RDB的机制，可以在`redis.conf`文件中找到，格式如下：

```shell
# 900s内，如果至少有一个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
```

## RDB的执行原理是什么呢

> ​	在Linux系统中，是不能直接拷贝物理内存中的数据的，但是有着**虚拟内存**的概念，而进程中有着**页表**的概念，它记录着虚拟地址与物理地址的映射关系。就可以通过**页表**去共享内存数据
>
> ​	`bgsave`开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。
>
> ​	`fork`采用的是`copy-on-write`技术
>
> - 当主进程执行读操作时，访问共享内存；
> - 当主进程执行写操作时，则会拷贝一份数据，执行写操作。

## 什么是AOF呢

> ​	AOF全称Append Only File（追加文件）。Redis处理的每一个`写命令`都会记录在AOF文件中，可以看作是日志文件。

AOF默认是关闭的，需要修改`redis.conf`配置文件来开启AOP:

```shell
#是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename "appendonly.aof"
```

AOF的命令记录的频率也可以通过`redis.conf`文件来配置：

```shell
# 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完先放入AOF缓存区，然后表示每隔1s将缓冲区数据写道AOF文件
appendfsync everysec
# 写命令执行完毕先放入AOF缓存区，由操作系统决定何时将缓存区内容写回磁盘
appendfsync no
```

|   配置项   |   刷盘时机   |          优点          |             缺点             |
| :--------: | :----------: | :--------------------: | :--------------------------: |
|   Always   |   同步刷盘   | 可靠性高，几乎不丢数据 |          性能影响大          |
| `everysec` |   每秒刷盘   |        性能适中        |        最多丢失1s数据        |
|     no     | 操作系统控制 |        性能最好        | 可靠性较差，可能丢失大量数据 |

> 缺点：
>
> ​	因为是记录命令。AOF文件会比RDB文件大的多。而且AOF会记录同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行`bgrewriteaof`命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。

Redis也会在触发阈值时自动重写AOF文件。阈值也可以在`redis.conf`中配置：

```shell
# AOF文件比上次文件增长多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
```

![image-20240605144320758](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240605144320758.png)

# 数据过期策略

> ​	Redis对数据设置数据的有效时间，数据过期以后，就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被成为数据的删除策略（数据过期策略）。

## 惰性删除

> ​	设置该key过期时间后，我们不去管他，当需要该key时，我们再检查是否过期，如果过期，我们就删除它，反之返回该key。

- 优点：对CPU友好，只有在使用该key时才会经i选哪个过期检查，对于很多用不到的key不用浪费时间进行过期检查
- 缺点：对内存不友好，如果一个key已经过期，但是一直没用，那么该key就会一直存在内存中，内存永远不释放。

## 定期删除

> 每隔一段时间，我们就会对一些key进行检查，删除里面过期的key（从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中过期的key）
>
> 定期删除有两种模式：
>
> - SLOW模式：定时任务。执行频率默认为10hz，每次不超过25ms,以通过修改配置文件的`hz`选项来调整这个次数。
> - FAST模式：执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms。

- 优点：可以通过限制删除操作执行的时长和频率来减少操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存。
- 缺点：难以确定删除执行操作的市场和频率。

**Redis的过期删除策略：惰性删除 + 定期删除两种策略进行配合使用。**

# 数据淘汰策略

> ​	当Redis中内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一规则的将内存中的数据删除掉，这种数据的删除规则被称为内存的淘汰策略。

Redis中支持八种不同策略来选择要删除的key：

- `noeviction`:不淘汰任何key，但是内存满时不允许写入新数据。**默认就是这种策略**
- `volatile-ttl`: 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰。
- `allkeys-random`: 对全体key，随机进行淘汰
- `volatile-random`:对设置了TTL的key，随机进行淘汰
- `allkeys-lru`: 对全体key，基于LRU算法进行淘汰
- `volatile-lru`:对设置了TTL的key，基于LRU算法进行淘汰
- `allkeys-lfu`: 对全体key，基于LFU算法进行淘汰
- `volatile-lfu`: 对设置了TTL的key，基于LFU算法进行淘汰

使用建议：

1. 优先使用 `allkeys-lru` 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。
2. 果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用 `allkeys-random`，随机选择淘汰。
3. 如果业务中有置顶的需求，可以使用`volatile-lru`策略，同时置顶数据不设置过期时间，这些数据就一直不被删除会淘汰其他设置过期时间的数据。
4. 如果业务中有短时高频访问的数据，可以使用 `alkeys-lfu`或`volatile-lfu`策略。

# 分布式锁

## Redis实现分布式锁

> ​	Redis实现分布式锁主要利用Redis的`setnx`命令。`setnx`是SET if not exists(如果不存在，则SET)的简写。

- 获取锁

```shell
# 添加锁、NX是互斥，EX是设置超时时间
SET lock value NX EX 10
```

- 释放锁

```shell
# 释放锁，删除即可
DEL key
```

## Redission实现分布式锁

### 执行流程

1. Watch dog 看门狗机制——**给锁续期操作**（默认是每隔10s续期一次）
2. 抢不到锁的进程会进行尝试等待
3. 所有的`redis`命令是根据`lua`脚本进行的,保证原子性

### 可重入

和Java多线程中的`ReentrantLock`实现是一样的

- 利用hash结构记录线程id和重入次数

### 主从一致性

`RedLock(红锁)`：不能只在一个Redis实例上创建锁，应该是在多个Redis实例上创建锁（n / 2 + 1），避免在一个实例上加锁

> 不建议使用

`redis`采用的是**AP思想**: 保证的是高可用性，可以做到最终的一致性

`zookeeper`采用的是**CP思想**：保证数据强一致性。

# Redis集群方案

- 主从复制
- 哨兵模式
- 分片集群

## 主从复制

> ​	单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。
>
> ​	一般是一主多从，主节点负责写数据，从节点负责读数据

### 主从数据同步原理：

- 主从**全量同步**：

![image-20240606143243784](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240606143243784.png)

- Replication Id: 简称`replid`, 是数据集的标记，id一致则说明是同一数据集，每一个master都有唯一的`replid`,slave则会继承master节点的`replid`。

- offset: 偏移量，随着记录在`repl_backlog`的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset，如果slave的offset小于master的offset，说明slave数据落后于master,需要更新。

1. 从节点请求主节点同步数据
2. 主节点判断是否是第一次请求，是第一次就与从节点同步版本信息
3. 主节点执行`bgsave`，生成RDB文件后，发送给从节点去执行
4. 在RDB生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件）
5. 把生成之后的命令日志文件发送到从节点进行同步。

- 主从**增量同步**（slave重启或后期数据变化）

1. 从节点请求主节点同步数据，主节点判断是否是第一次请求，不是第一次就获取从节点的offset值
2. 主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。

## 哨兵模式

> 哨兵的作用：
>
> ​	Redis提供了哨兵(Sentinel)机制来实现主从集群的自动故障恢复。

哨兵的作用如下：

- **监控**: Sentinel会不断检查你的master和slave是否按预期工作。
- **自动故障恢复**：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。
- **通知**：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给Redis的客户端。

服务状态监控：

Sentinel基于心跳机制监测服务状态，每隔1s向集群的每个实例发送ping命令。

- 主观下线：如果sentinel节点发现某实例未在规定时间响应，则认为该实例**主观下线**。
- 客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则认为实例客观下线。quorum值最好超过Sentinel实例数量的一半。

哨兵选主规则：

- 首先判断主与从节点断开时间长短，如超过指定值就排除该从节点
- 然后判断从节点的slave-priority值，越小优先级越高
- 如果slave-priority一样，则判断slave节点的offset值，越大优先级越高
- 最后判断slave节点的运行id大小，越小优先级越高。

### Redis集群(哨兵模式)脑裂：

> ​	**集群脑裂**是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失
>
> 解决：
>
> ​	我们可以修改Redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失。

## 分片集群

主从可以解决高并发的问题，哨兵模式能解决高可用的问题。但是要解决下面两个问题：

- 海量数据存储问题
- 高并发写的问题

就可以使用分片集群了，分片集群特征：

- 集群中有多个master，每隔master保存不同数据
- 每个master都可以有多个slave节点。
- master之间通过ping监测彼此健康状态。
- 客户端请求可以访问集群任意节点，最终都会被转发到正确节点。

### 数据读写

>  	Redis分片集群引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。

> 读写数据：
>
> ​	根据key的有效部分计算哈希值，对16384取余（有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分）余数做为插槽，寻找插槽所在的实例

## Redis是单线程的，但是为什么还那么快

- Redis是纯内存操作，执行速度非常快
- 采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题。
- 使用I/O多路复用模型，非阻塞IO

什么是I/O多路复用模型：

> ​	Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，I/O多路复用模型主要就是实现了高效的网络请求
>
> - 用户空间和内核空间
> - 常见的IO模型
>   - 阻塞IO
>   - 非阻塞IO
>   - IO多路复用
>     - 是利用单个线程来同时监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。
> - Redis网络模型

### 用户空间和内核空间

- Linux系统中一个进程使用的内存情况划分两部分：内核空间、用户空间
- 用户空间只能执行受限的命令（`Ring3`）,而且不能直接调用系统资源必须通过内核提供的接口来访问
- 内核空间可以执行特权命令（`Ring0`）,调用一切系统资源

### IO多路复用

![image-20240606162612845](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240606162612845.png)

### Redis网络模型

> ​	Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装，提供了统一的高性能事件库

影响性能的永远是IO

![image-20240606162854450](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240606162854450.png)
