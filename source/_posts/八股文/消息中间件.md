---
title: 消息中间件
date: 2024-6-10
updated: 2024-6-10
categories: "面试"
tags: 
	- "消息中间件"
	- "八股文"
---

# 消息中间件

- Rabbit MQ
  - 消息不丢失
  - 消息重复消费
  - 消息堆积
  - 延迟队列
  - 死信队列
  - 高可用机制
- Kafka
  - 消息不丢失
  - 消息重复消费
  - 消息堆积
  - 延迟队列
  - 死信队列
  - 高可用机制
  - 高性能设计
  - 数据存储和清理

# Rabbit MQ

## 如何保证消息不丢失

- 异步发送(验证码、短信、邮件...)
- MySQL 和 Redis, ES 之间的数据同步
- 分布式事务
- 削峰填谷

### 生产者确认机制

> ​	RabbitMQ提供了`publisher confirm`机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功

消息失败之后如何处理呢?

- 回调方法即时重发
- 记录日志
- 保存到数据库中然后定时重发，成功发送后即刻删除表中的数据

### 消息持久化

> ​	MQ默认是内存存储消息, 开启持久化功能可以确保缓冲在MQ中的消息不丢失。

1. 交换机持久化

```java
@Bean
public DirectExchange simpleExchange() {
    // 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除
    return new DireExchange("simple.direct", true, false);
}
```

2. 队列持久化

```java
@Bean
public Queue simpleQueue() {
    //使用QueueBuilder构建队列，durable就是持久化的
    return QueueBuilder.durable("simple.queue").build();
}
```

3. 消息持久化, `SpringAMQP`中的消息默认是持久的，可以通过`MessageProperties`中的`DeliveryMode`来指定

```java
Message msg = MessageBuilder
    	.withBody(message.getBytes(StandardCharsets.UTF_8))
    	.setDeliveryMode(MessageDeliveryMode.PERSISTENT)
    	.build();
```

### 消费者确认

> ​	RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而`SpringAMQP`则允许配置三种确认模式：
>
> - `manual`：手动ack，需要在业务代码结束后，调用`api`发送`ack`。
> - `auto`：自动ack，由`spring`监测`listener`代码是否出现异常，没有异常则返回`ack`；抛出异常则返回`nack`
> - `none`：关闭ack，MQ 假定消费者获取消息后会成功处理，因此消息投递后立即被删除

​	我们可以利用`Spring`的`retry`机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理

### 总结

- 开启生产者确认机制，确保生产者的消息能到达队列
- 开启持久化功能，确保消息未消费前在队列中不会丢失
- 开启消费者确认机制为auto，由spring确认消息处理成功后完成ack
- 开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理

## 消息的重复消费问题

- 网络抖动
- 消费者挂了

解决方案：适用于任何MQ

- 每条消息设置一个唯一的标识id
- 幂等方案：【分布式锁、数据库锁（悲观锁、乐观锁）】

## Rabbit MQ 死信交换机、延迟队列

> 延迟队列：进入队列的消息会被延迟消费的队列
>
> 场景：
>
> - 超时订单
> - 限时优惠
> - 定时发布
>
> 延迟队列 = 死信交换机 + TTL（生存时间）

### 死信交换机

当一个队列中的消息满足下列情况之一时，可以称为**死信（dead letter）**

- 消费者使用`basic.reject`或`basic.nack`声明消费失败，并且消息的requeue参数设置为false
- 消息是一个过期消息，超时无人消费
- 要投递的队列消息堆积满了，最早的消息可能成为死信

如果该队列`配置了dead-letter-exchange属性`，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为`死信交换机（DeadLetterExchange，简称DLX）`。

```java
@Bean
public Queue ttlQueue() {
	return QueueBuilder.durable("simple.queue")
        .ttl(1000) // 设置队列的超时时间，10s
        .deadLetterExchange("dl.direct") // 指定死信交换机
        .build();
}
```

### TTL

> ​	TTL，也就是`Time-To-Live`。如果一个队列中的消息TTL结束仍未消费，则会变为死信，`ttl`超时分为两种情况：
>
> - 消息所在的队列设置了存活时间
> - 消息本身设置了存活时间

![image-20240610224545081](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240610224545081.png)

### 延迟队列插件

`DelayExchange`插件，需要安装在RabbitMQ中RabbitMQ有一个官方的插件社区，地址为：https://www.rabbitmq.com/community-plugins.html

`DelayExchange`的本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为true即可。

![image-20240610224716961](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240610224716961.png)

![image-20240610224723791](https://bed.flyone.space/%E7%AC%94%E8%AE%B0/image-20240610224723791.png)

## 息堆积怎么解决

RabbitMQ如果有100万消息堆积在MQ，如何解决（消息堆积怎么解决）？

> ​	当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题

解决消息堆积有三种种思路：

- 增加更多消费者，提高消费速度
- 在消费者内开启线程池加快消息处理速度
- 扩大队列容积，提高堆积上限, 采用**惰性队列**

### 惰性队列

> ​	惰性队列的特征如下：
>
> - 接收到消息后直接存入磁盘而非内存
> - 消费者要消费消息时才会从磁盘中读取并加载到内存
> - 支持数百万条的消息存储

- 配置方式

```java
@Bean
public Queue lazyQueue() {
    return QueueBuilder
        .durable("lazy.queue")
        .lazy() // 开启x-queue-mode为lazy
        .build();
}
```

- 注解方式

```java
@RabbitListener(queuesToDeclare = @Queue(
		name = "lazy.queue",
    	durable="true",
    	arguments = @Argument(name = "x-queue-mode", value = "lazy")
))
public void listenLazyQueue(String msg) {
    log.info("接收到 lazy.queue的消息：{}", msg);
}
```

## 高可用机制

RabbitMQ的高可用机制有了解过嘛？

- 在生产环境下，使用集群来保证高可用性
- 普通模式集群
- **镜像模式集群**
- 仲裁模式集群

### 普通集群

> ​	普通集群，或者叫标准集群（classic cluster），具备下列特征：
>
> - 会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。
> - 当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回
> - 队列所在节点岩机，队列中的消息就会丢失

### 镜像集群

> ​	镜像集群：本质是主从模式，具备下面的特征：
>
> - 交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。
> - 创建队列的节点被称为该队列的主节点，备份到的其它节点叫做该队列的镜像节点。
> - 一个队列的主节点可能是另一个队列的镜像节点
> - 所有操作都是主节点完成，然后同步给镜像节点
> - 主宕机后，镜像节点会替代成新的主

### 仲裁队列

> ​	仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：
>
> - 与镜像队列一样，都是主从模式，支持主从数据同步
> - 使用非常简单，没有复杂的配置主从同步
> - 基于Raft协议，强一致

```java
@Bean
public Queue quorumQueue() {
    return QueueBuilder
        .durable("quorum.queue") // 持久化
        .quorum() // 仲裁队列
        .build();
}
```

